// Hearse is a small compiler + interpreter for Brainfuck written entirely in Go
package main

import (
	"fmt"
	"strings"
)

type Op int

type Instruction struct {
	Op 	Op
	Arg int
	Next *Instruction
	Prev *Instruction
	Offset *Instruction
}

type AST struct {
	Instructions []*Instruction
}

const (
	INCREMENT_POINTER Op = iota
	DECREMENT_POINTER
	INCREMENT_VALUE
	DECREMENT_VALUE
	OUTPUT_VALUE
	INPUT_VALUE
	JUMP_FORWARD
	JUMP_BACKWARD
)

func Parse(code string) *AST {
	root := &Instruction{}
	curr := root

	for _, c := range code {
		switch c {
		case '>':
			curr.Next = &Instruction{Op: INCREMENT_POINTER, Prev: curr}
		case '<':
            curr.Next = &Instruction{Op: DECREMENT_POINTER, Prev: curr}
            curr = curr.Next
        case '+':
            curr.Next = &Instruction{Op: INCREMENT_VALUE, Prev: curr}
            curr = curr.Next
        case '-':
            curr.Next = &Instruction{Op: DECREMENT_VALUE, Prev: curr}
            curr = curr.Next
        case '.':
            curr.Next = &Instruction{Op: OUTPUT_VALUE, Prev: curr}
            curr = curr.Next
        case ',':
            curr.Next = &Instruction{Op: INPUT_VALUE, Prev: curr}
            curr = curr.Next
        case '[':
            curr.Next = &Instruction{Op: JUMP_FORWARD, Prev: curr}
            curr = curr.Next
        case ']':
            curr.Next = &Instruction{Op: JUMP_BACKWARD, Prev: curr}
            curr = curr.Next
		}
	}


	root = root.Next

	var stack []*Instruction

	for curr := root; curr != nil; curr = curr.Next {
		switch curr.Op {
		case JUMP_FORWARD:
			stack = append(stack, curr)
		case JUMP_BACKWARD:
			if len(stack) == 0 {
				panic("Unmatched ]!")
			}
			forward := stack[len(stack) - 1]
			stack = stack[:len(stack) - 1]
			curr.Offset = forward
			forward.Offset = curr
		}
	}

	if len(stack) != 0 {
		panic("Unmatched [!")
	}

	ast := &AST{Instructions: make([]*Instruction, 0)}
	for curr := root; curr != nil; curr = curr.Next {
		if curr.Op != JUMP_FORWARD && curr.Op != JUMP_BACKWARD {
			ast.Instructions = append(ast.Instructions, curr)
		}
	}

	return ast
}

func Interpret(ast *AST) {
	tape := make([]byte, 30000)
	ptr := 0

	for _, inst := range ast.Instructions {
		switch inst.Op {
		case INCREMENT_POINTER:
			ptr++
		case DECREMENT_POINTER:
			ptr--
		case INCREMENT_VALUE:
			tape[ptr]++
		case DECREMENT_VALUE:
			tape[ptr]--
		case OUTPUT_VALUE:
			fmt.Printf(string(tape[ptr]))
		case INPUT_VALUE:
			var input byte
			fmt.Scan(&input)
			tape[ptr] = input
		case JUMP_FORWARD:
			if tape[ptr] == 0 {
				inst = inst.Offset
			}
		case JUMP_BACKWARD:
			if tape[ptr] != 0 {
				inst = inst.Offset
			}
		}
	}
}

func compileToC(ast *AST) string {

	const INFORMATION_TEMPLATE = `
	/* Compiler: Hearse */
	/* This code is autogenerated. */`

	var cCode strings.Builder

	// Generate boilerplate code
	// HEAD
	cCode.WriteString(INFORMATION_TEMPLATE)
	cCode.WriteString("#include <stdio.h>\n")
	cCode.WriteString("#include <stdlib.h>\n")
	cCode.WriteString("char tape[30000];\n")
	cCode.WriteString("char *ptr = tape;\n")
	cCode.WriteString("int main() {\n")

	// Generate body
	for _, inst := range ast.Instructions {
		switch inst.Op {
		case INCREMENT_POINTER:
			cCode.WriteString("++ptr;\n")
		case DECREMENT_POINTER:
			cCode.WriteString("--ptr;\n")
		case INCREMENT_VALUE:
			cCode.WriteString("++*ptr;\n")
		case DECREMENT_VALUE:
			cCode.WriteString("--*ptr;\n")
		case OUTPUT_VALUE:
			cCode.WriteString("putchar(*ptr);\n")
		case INPUT_VALUE:
			cCode.WriteString("*ptr = getchar();\n")
		case JUMP_FORWARD:
			cCode.WriteString("while (*ptr) {\n")
			cCode.WriteString(fmt.Sprintf("ptr += %d;\n", inst.Arg))
			cCode.WriteString("}\n")
		case JUMP_BACKWARD:
			cCode.WriteString("while (*ptr) {\n")
			cCode.WriteString(fmt.Sprintf("ptr -= %d;\n", inst.Arg))
			cCode.WriteString("}\n")
		}
	}

	// EOF
	cCode.WriteString("return 0;\n")
	cCode.WriteString("}\n")

	return cCode.String()
}
